---
title: "Imbalanced integration guidelines tutorial - R"
output: rmarkdown::html_vignette
date: '2023-04-24'
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  tidy = TRUE,
  fig.height = 4,
  fig.width = 6,
  message = FALSE,
  warning = FALSE
)
options(future.globals.maxSize = 8000 * 1024^2)
```

This tutorial is based on the [Imbalanced integration guidelines](https://www.biorxiv.org/content/10.1101/2022.10.06.511156v3.full) in the Iniquitate manuscript. This example explores integration in the case of a dataset comprising of two batches of PBMC data, for which a modified version was used in the paper experiments - namely dataset number 5 from the [Tran et al. scRNA-seq integration benchmarking paper](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1850-9#availability-of-data-and-materials). To simulate a case where significant cell-type imbalance exists between the batches in this dataset, we first dropped non-prevalent populations from both batches (<200 cells per batch, which included megakaryocytes, Plasmacytoid dendritic cells, and hematopoetic stem cells), and then removed CD4+ T cells and CD14+ Monocytes from batch 1. As demonstrated in the paper experiments, cell-type imbalance combined with proximity to similar cell-types can lead to loss of information about the imbalanced cell-types in the integrated space. Given that CD4+ T cells are in transcriptional proximity to CD8+ T cells and NK cells, and CD14+ Monocytes are in proximity to CD16+ Monocytes, and combined with the fact that they are imbalanced in this data, we would expect that integration methods might lead to loss of biological signal. 

These facts are known to us because we know the cell-type labels, but we'll play the role of a researcher that has obtained these two batches in an unsupervised manner and demonstrate how the guidelines can be used. 

We'll begin by examining the properties of these two batches. 

## Dataset exploration 

Start by downloading the data - both batches:
```{r, results="hide"}
library(googledrive)

# Create data directory
if (!dir.exists("data")){
  dir.create("data")  
}

# Install files if not already present
if (!(file.exists("data/tran_et_al_batch_1.h5ad"))) {    
  # Remove authorization for Google Drive
  drive_deauth()
  drive_user()
  
  # Download the files
  file_id_1 <- as_id("1LryRxnVGq2Ny4awDxyiS84oou_zkvQki")
  file_id_2 <- as_id("1JMhR3cGGj4pueSLiFCPYl19jZDUKmznR")
  file_1 <- drive_get(file_id_1)
  file_2 <- drive_get(file_id_2)
  googledrive::drive_download(
    file_1, 
    path = "data/tran_et_al_batch_1.h5ad", 
    overwrite=TRUE
  )
  googledrive::drive_download(
    file_2,
    path = "data/tran_et_al_batch_2.h5ad",
    overwrite=TRUE
  )
}
```

Read in both files using the SeuratDisk library (we'll need to install it first but this shouldn't take long). We'll use the `Seurat` library for processing and analyzing the data:
```{r, results="hide"}
if (!requireNamespace("remotes", quietly = TRUE)) {
  install.packages("remotes")
}
remotes::install_github("mojaveazure/seurat-disk")
library(SeuratDisk)

# Convert the tran et al files to h5seurat format
Convert(
  "data/tran_et_al_batch_1.h5ad", 
  dest = "h5seurat", 
  overwrite = TRUE
)
Convert(
  "data/tran_et_al_batch_2.h5ad",
  dest = "h5seurat",
  overwrite = TRUE
)

# Load h5ad files for both batches
pbmc_1 <- SeuratDisk::LoadH5Seurat("data/tran_et_al_batch_1.h5seurat")
pbmc_2 <- SeuratDisk::LoadH5Seurat("data/tran_et_al_batch_2.h5seurat")
```

Examine the cell-type distribution for each batch:
```{r}
library(ggplot2)
library(ggthemes)

# Grab the metadata
meta_1 <- pbmc_1@meta.data
meta_2 <- pbmc_2@meta.data

# Print and plot the cell-type distribution for each batch
print(table(meta_1$celltype))
ggplot(data = meta_1, aes(celltype,fill=as.factor(celltype))) + 
  geom_histogram(stat="count") +
  labs(
    fill = "Cell-type",
    x = "Cell-type",
    y = "Count in batch 1"
  ) +
  theme_few() +
  theme(axis.title.x = element_text(size = 16)) +
  theme(axis.title.y = element_text(size = 16)) +
  theme(strip.text.x = element_text(size = 16)) +
  theme(plot.title = element_text(size = 14)) +
  theme(axis.text.x = element_text(size = 16)) +
  theme(axis.text.y = element_text(size = 16)) +
  theme(legend.title = element_text(size = 16)) +
  theme(legend.text = element_text(size = 16))

print(table(meta_2$celltype))
ggplot(data = meta_2, aes(celltype,fill=as.factor(celltype))) + 
  geom_histogram(stat="count") +
  labs(
    fill = "Cell-type",
    x = "Cell-type",
    y = "Count in batch 2"
  ) +
  theme_few() +
  theme(axis.title.x = element_text(size = 16)) +
  theme(axis.title.y = element_text(size = 16)) +
  theme(strip.text.x = element_text(size = 16)) +
  theme(plot.title = element_text(size = 14)) +
  theme(axis.text.x = element_text(size = 16)) +
  theme(axis.text.y = element_text(size = 16)) +
  theme(legend.title = element_text(size = 16)) +
  theme(legend.text = element_text(size = 16))
```
As we can see from the results, there is an obvious **imbalance in terms of the cell-types present in both batches**, and that the **CD4+ T cells** and **CD14+ Monocytes** only exist in batch 2. 

Now that we've seen the imbalance present in this dataset, we're going to take the role of a single-cell analysis practitioner that **does not know the underlying cell-type distribution of this dataset**. I.e. we don't know what cell-types are present and our goal is to learn a joint representation of these two batches of pbmc cells that we've obtained from an experiment. 

We'll start from the top of the guidelines and work our way down.

## Pre-integration stage

The first stage of the guidelines focuses on checks before integration, to determine whether or not an imbalance might be present in the dataset. This serves as a prior for our integration experiment, and combined with the post-integration diagnostics, helps inform whether or not we need to tune the tradeoff between *preserving biological heterogeneity* and *batch mixing*. 

Let's make our way down the flowchart. 

### Unsupervised clustering within each batch

The first step is to perform unsupervised clustering within each batch. We don't have any labels in this scenario, so we perform unsupervised clustering to gauge if different cell-types might be present based on the number and proportion of clusters between batches.

Using `Seurat`, start by performing normalization, highly-variable gene selection, PCA-reduction, and unsupervised clustering of each batch separately. Then we can visualize the results using UMAP:
```{r, warning=FALSE}
library(Seurat)

# Preprocess the data using Seurat - Normalize and scale  
pbmc_1 <- NormalizeData(
  pbmc_1, normalization.method = "LogNormalize", scale.factor = 10000,
  verbose = FALSE
)
pbmc_1 <- FindVariableFeatures(pbmc_1, nfeatures = 2000, verbose = FALSE)
all.genes <- rownames(pbmc_1)
pbmc_1 <- ScaleData(pbmc_1, features = all.genes, verbose = FALSE)

# Run PCA, create neighborhood graph and get the clusters using the Leiden
# algorithm 
pbmc_1 <- RunPCA(
  pbmc_1, features = VariableFeatures(pbmc_1), verbose = FALSE
)
pbmc_1 <- FindNeighbors(pbmc_1, dims = 1:10, verbose = FALSE)
pbmc_1 <- FindClusters(
  pbmc_1, resolution = 0.5, algorithm = "leiden", verbose = FALSE
)

# Get the UMAP reduction of the data
pbmc_1 <- RunUMAP(
  pbmc_1, umap.method = "umap-learn", dims = 1:10, verbose = FALSE
)

# Do the same for pbmc 2 
pbmc_2 <- NormalizeData(
  pbmc_2, normalization.method = "LogNormalize", scale.factor = 10000,
   verbose = FALSE
)
pbmc_2 <- FindVariableFeatures(pbmc_2, nfeatures = 2000, verbose = FALSE)
all.genes <- row.names(pbmc_2)
pbmc_2 <- ScaleData(pbmc_2, features = all.genes, verbose = FALSE)
pbmc_2 <- RunPCA(
  pbmc_2, features = VariableFeatures(pbmc_2),  verbose = FALSE
)
pbmc_2 <- FindNeighbors(pbmc_2, dims = 1:10, verbose = FALSE)
pbmc_2 <- FindClusters(
  pbmc_2, resolution = 0.5, algorithm = "leiden", verbose = FALSE
)
pbmc_2 <- RunUMAP(
  pbmc_2, umap.method = "umap-learn", dims = 1:10, verbose = FALSE
)
```

Plot the UMAP reduction of the clustering results for each individual batch:
```{r}
DimPlot(pbmc_1, reduction = "umap")
DimPlot(pbmc_2, reduction = "umap")
```

As we can see from the plots, there are differences in the number of clusters and possible proportion differences between the batches. We can examine this a bit closer using barplots:
```{r}
library(ggplot2)

# Update metadata (previously set variable)
meta_1 <- pbmc_1@meta.data
meta_2 <- pbmc_2@meta.data

# Plot the number of clusters and proportions for both datasets
ggplot(meta_1, aes(x=seurat_clusters)) +
  geom_bar(fill="dodgerblue2") +
  labs(
    x = "Cluster",
    y = "Count in batch 1"
  ) +
  theme_few() +
  theme(axis.title.x = element_text(size = 16)) +
  theme(axis.title.y = element_text(size = 16)) +
  theme(strip.text.x = element_text(size = 16)) +
  theme(plot.title = element_text(size = 14)) +
  theme(axis.text.x = element_text(size = 16)) +
  theme(axis.text.y = element_text(size = 16)) +
  theme(legend.title = element_text(size = 16)) +
  theme(legend.text = element_text(size = 16))
  

ggplot(meta_2, aes(x=seurat_clusters)) + 
  geom_bar(fill="dodgerblue2") +
    labs(
    x = "Cluster",
    y = "Count in batch 2"
  ) +
  theme_few() +
  theme(axis.title.x = element_text(size = 16)) +
  theme(axis.title.y = element_text(size = 16)) +
  theme(strip.text.x = element_text(size = 16)) +
  theme(plot.title = element_text(size = 14)) +
  theme(axis.text.x = element_text(size = 16)) +
  theme(axis.text.y = element_text(size = 16)) +
  theme(legend.title = element_text(size = 16)) +
  theme(legend.text = element_text(size = 16))

  
```

From the barplots, we can see that the number of cells across clusters follows a similar distribution, but the fact that batch 2 contains more clusters at the same Leiden resolution signals that there may be an imbalance present between the batches of this dataset. We'll keep this in mind as we continue.

Continuing down the flowchart for the **pre-integration stage**, we check if we have a reference dataset available. Let's assume we don't for brevity, but if we did, we would annotate each batch individually, and then check the same barplots as above, but with cell-type labels instead of clusters. We'd likely arrive at a similar conclusion. 

Given that we found that there may be composition differences, it would be prudent to think about how to tune the tradeoff between *biological heterogeneity preservation* and *batch mixing*. Examining the [landmark benchmarking paper from Leuken et al.](https://www.nature.com/articles/s41592-021-01336-8) is another aspect of the guidelines. The major figures to examine would be Figure 3 (for RNA-based integration tasks) and Figure 5. From the paper we know that scGen and scANVI perform best when conserving biological heterogeneity, but their implementations in the paper required cell-type labels, which we do not have in this hypothetical analysis. A dataset of two pbmc batches is not a highly complex scenario, and in relatively simpler scenarios with batch effects, Seuratv3 was found to integrate strong technical effects (batch mixing), while Harmony was found to better performer in conserving biological signal.

We do not know a-priori how strong the technical effects are between our pbmc batches - we only know that there might be composition differences. We'll use our post-integration diagnostics to assess how well the results meet our criteria for preserving biological heterogeneity and batch mixing. Our **optimal** setup will involve adequate batch correction (not necessarily the strongest) without sacrificing biological signal. As such, we will begin by testing both Seuratv3 canonical correlation analysis (CCA) and Harmony for integration.

## Integration stage 

Lets start by integrating using Seurat CCA first:
```{r}
library(Seurat)

# Include a batch covariate for integration in the metadata
pbmc_1@meta.data$batch <- "Batch 1"
pbmc_2@meta.data$batch <- "Batch 2"

# Obtain anchors between the two batches and perform CCA-base integration
# using Seurat (the default)
pbmc_list <- c(pbmc_1, pbmc_2)
features <- SelectIntegrationFeatures(
  object.list = pbmc_list, verbose = FALSE
)
anchors <- FindIntegrationAnchors(
  object.list = pbmc_list, anchor.features = features, verbose = FALSE
)
pbmc_integrated <- IntegrateData(anchorset=anchors, verbose = FALSE)

# Using the integrated representation, obtain a reduced representation
# through PCA, cluster the joint representation and obtain UMAP coordinates
pbmc_integrated <- ScaleData(pbmc_integrated, verbose = FALSE)
pbmc_integrated <- RunPCA(pbmc_integrated, verbose = FALSE)
pbmc_integrated <- FindNeighbors(
  pbmc_integrated, reduction="pca", dims=1:15, verbose = FALSE
)
pbmc_integrated <- FindClusters(
  pbmc_integrated, resolution=0.5, algorithm="leiden", verbose = FALSE
)
pbmc_integrated <- RunUMAP(
  pbmc_integrated, reduction="pca", dims=1:15, verbose = FALSE
)

```

## Post-integration stage

Let's examine the Seuratv3 CCA integration results by UMAP:
```{r}
DimPlot(pbmc_integrated, reduction="umap", group.by="batch")
DimPlot(pbmc_integrated, reduction="umap", group.by="seurat_clusters")
```
### Measure degree of batch mixing post-integration

From the UMAP plots we can clearly see that there is a strong degree of batch mixing. However, we don't know whether or not this have removed biological signal yet. We can first simply quantify the batch mixing by comparing the cluster labels with the batch labels using the `Adjusted Rand Index` (ARI). We'll use 1 - ARI, as a high score should indicate that the cluster labels and batch labels do not correspond - indicating strong batch mixing. 
```{r}
library(bluster)
batch_labels <- pbmc_integrated@meta.data$batch
integrated_cluster_labels <- pbmc_integrated@meta.data$seurat_clusters
batch_ari <- 1 - pairwiseRand(batch_labels, integrated_cluster_labels, mode = "index")
print(paste0("Batch mixing ARI: ", batch_ari))
```

A score near 1 would indicate perfect batch mixing, and thus using Seuratv3 CCA, the results show that the batch mixing is very strong. 

However, we still don't have an 

# Strong batch mixing - check diagnostics for cell-type heterogeneity conservation

```{r}
library(pheatmap)

cluster_labels_b1_before <- pbmc_1@meta.data$seurat_clusters
cluster_labels_b2_before <- pbmc_2@meta.data$seurat_clusters

cluster_labels_b1_after <- pbmc_integrated@meta.data$seurat_clusters[
  pbmc_integrated@meta.data$batch == "Batch 1"
]
cluster_labels_b2_after <- pbmc_integrated@meta.data$seurat_clusters[
  pbmc_integrated@meta.data$batch == "Batch 2"
]

tab_b1 <- nestedClusters(
  ref=paste("Before", cluster_labels_b1_before), 
  alt=paste("After", cluster_labels_b1_after)
)
tab_b2 <- nestedClusters(
  ref=paste("Before", cluster_labels_b2_before),
  alt=paste("After", cluster_labels_b2_after)
)

heat_b1 <- pheatmap(
  tab_b1$proportions,
  cluster_row=FALSE,
  cluster_col=FALSE,
  main="pbmc Batch 1 Comparison",
  silent=TRUE
)
heat_b2 <- pheatmap(
  tab_b2$proportions,
  cluster_row=FALSE,
  cluster_col=FALSE,
  main="pbmc Batch 2 Comparison",
  silent=TRUE
)

gridExtra::grid.arrange(heat_b1[[4]], heat_b2[[4]])
```

# Check the batch-based cell-type cluster heterogeneity conservation scores

```{r}
b1_ari <- pairwiseRand(
  cluster_labels_b1_before,
  cluster_labels_b1_after,
  mode="index"
)
b2_ari <- pairwiseRand(
  cluster_labels_b2_before,
  cluster_labels_b2_after,
  mode="index"
)
print(paste0("Batch 1 ARI: ", b1_ari))
print(paste0("Batch 2 ARI: ", b2_ari))
```

# Looks like the heterogeneity conservation for batch 2 is much worse than batch 1 - might
# be specific cell-types in there that not present in batch 1 (imbalance)
# This is also reflected in the cluster plots themselves (expand on this)

# For us, the tradeoff between batch mixing and preserving heterogeneity not adaquete 
# as we lose a lot of information from batch 2 after integration

# Want to tune in such a manner that increases heterogeneity preservation 

# We're going to modify the seurat approach to use reciprocal PCA instead of CCA (expand on this, but
# not too much)

```{r}
features <- SelectIntegrationFeatures(
  object.list = pbmc_list, verbose = FALSE
)
pbmc_list <- lapply(pbmc_list, function(x) {
  x <- ScaleData(x, features = features, verbose = FALSE)
  x <- RunPCA(x, features = features, verbose = FALSE)
})
anchors <- FindIntegrationAnchors(
  object.list = pbmc_list,
  anchor.features = features,
  reduction = "rpca",
  verbose = FALSE
)
pbmc_integrated <- IntegrateData(anchorset = anchors, verbose = FALSE)

DefaultAssay(pbmc_integrated) <- "integrated"
pbmc_integrated <- ScaleData(pbmc_integrated, verbose = FALSE)
pbmc_integrated <- RunPCA(pbmc_integrated, npcs=15, verbose = FALSE)
pbmc_integrated <- FindNeighbors(
  pbmc_integrated, reduction="pca", dims=1:15, verbose = FALSE
)
pbmc_integrated <- FindClusters(
  pbmc_integrated, resolution=0.5, algorithm="leiden", verbose = FALSE
)
pbmc_integrated <- RunUMAP(
  pbmc_integrated, reduction="pca", dims=1:15, verbose = FALSE
)
```

# Plot and visualize the results 
```{r}
DimPlot(pbmc_integrated, reduction="umap", group.by="batch")
DimPlot(pbmc_integrated, reduction="umap", group.by="seurat_clusters")
```

# Measure the degree of batch mixing 
```{r}
library(bluster)
batch_labels <- pbmc_integrated@meta.data$batch
integrated_cluster_labels <- pbmc_integrated@meta.data$seurat_clusters
a <- 1 - pairwiseRand(batch_labels, integrated_cluster_labels)
a
```

# Strong batch mixing - check diagnostics for cell-type heterogeneity conservation

```{r}
library(pheatmap)

cluster_labels_b1_before <- pbmc_1@meta.data$seurat_clusters
cluster_labels_b2_before <- pbmc_2@meta.data$seurat_clusters

cluster_labels_b1_after <- pbmc_integrated@meta.data$seurat_clusters[
  pbmc_integrated@meta.data$batch == "Batch 1"
]
cluster_labels_b2_after <- pbmc_integrated@meta.data$seurat_clusters[
  pbmc_integrated@meta.data$batch == "Batch 2"
]

tab_b1 <- nestedClusters(
  ref=paste("Before", cluster_labels_b1_before), 
  alt=paste("After", cluster_labels_b1_after)
)
tab_b2 <- nestedClusters(
  ref=paste("Before", cluster_labels_b2_before),
  alt=paste("After", cluster_labels_b2_after)
)

heat_b1 <- pheatmap(
  tab_b1$proportions,
  cluster_row=FALSE,
  cluster_col=FALSE,
  main="pbmc Batch 1 Comparison",
  silent=TRUE
)
heat_b2 <- pheatmap(
  tab_b2$proportions,
  cluster_row=FALSE,
  cluster_col=FALSE,
  main="pbmc Batch 2 Comparison",
  silent=TRUE
)

gridExtra::grid.arrange(heat_b1[[4]], heat_b2[[4]])
```

# Check the batch-based cell-type cluster heterogeneity conservation scores

```{r}
b1_ari <- pairwiseRand(
  cluster_labels_b1_before,
  cluster_labels_b1_after,
  mode="index"
)
b2_ari <- pairwiseRand(
  cluster_labels_b2_before,
  cluster_labels_b2_after,
  mode="index"
)
print(paste0("Batch 1 ARI: ", b1_ari))
print(paste0("Batch 2 ARI: ", b2_ari))
```

# 

# The scores do improve - lets try one more method in Harmony 
```{r, eval=FALSE}
library(harmony)
rm(pbmc_integrated)
rm(pbmc_2_sce)
rm(pbmc_1_sce)
rm(pbmc_list)
gc()

pbmc_combined <- merge(pbmc_1, pbmc_2)
rm(pbmc_1)
rm(pbmc_2)
pbmc_combined <- NormalizeData(
  pbmc_combined, normalization.method = "LogNormalize", scale.factor = 10000
)
pbmc_combined <- FindVariableFeatures(pbmc_combined, nfeatures = 2000)
all.genes <- rownames(pbmc_combined)
pbmc_combined <- ScaleData(pbmc_combined, features = all.genes)
pbmc_combined <- RunPCA(pbmc_combined, features = VariableFeatures(pbmc_combined))
pbmc_combined <- RunHarmony(pbmc_combined, "batch")

pbmc_combined <- FindNeighbors(pbmc_combined, reduction="harmony", dims=1:15)
pbmc_combined <- FindClusters(pbmc_combined, resolution=0.5, algorithm="leiden")
pbmc_combined <- RunUMAP(pbmc_combined, reduction="harmony", dims=1:15)
```

# Plot and visualize the results 
```{r, eval=FALSE}
DimPlot(pbmc_combined, reduction="umap", group.by="batch")
DimPlot(pbmc_combined, reduction="umap", group.by="seurat_clusters")
```

# Measure the degree of batch mixing 
```{r, eval=FALSE}
library(bluster)
batch_labels <- pbmc_combined@meta.data$batch
integrated_cluster_labels <- pbmc_combined@meta.data$seurat_clusters
a <- 1 - pairwiseRand(batch_labels, integrated_cluster_labels)
a
```

# Strong batch mixing - check diagnostics for cell-type heterogeneity conservation

```{r, eval=FALSE}
library(pheatmap)

cluster_labels_b1_after <- pbmc_combined@meta.data$seurat_clusters[
  pbmc_combined@meta.data$batch == "Batch 1"
]
cluster_labels_b2_after <- pbmc_combined@meta.data$seurat_clusters[
  pbmc_combined@meta.data$batch == "Batch 2"
]

tab_b1 <- nestedClusters(
  ref=paste("Before", cluster_labels_b1_before), 
  alt=paste("After", cluster_labels_b1_after)
)
tab_b2 <- nestedClusters(
  ref=paste("Before", cluster_labels_b2_before),
  alt=paste("After", cluster_labels_b2_after)
)

heat_b1 <- pheatmap(
  tab_b1$proportions,
  cluster_row=FALSE,
  cluster_col=FALSE,
  main="pbmc Batch 1 Comparison",
  silent=TRUE
)
heat_b2 <- pheatmap(
  tab_b2$proportions,
  cluster_row=FALSE,
  cluster_col=FALSE,
  main="pbmc Batch 2 Comparison",
  silent=TRUE
)

gridExtra::grid.arrange(heat_b1[[4]], heat_b2[[4]])
```

# Check the batch-based cell-type cluster heterogeneity conservation scores

```{r, eval=FALSE}
b1_ari <- pairwiseRand(
  cluster_labels_b1_before,
  cluster_labels_b1_after,
  mode="index"
)
b2_ari <- pairwiseRand(
  cluster_labels_b2_before,
  cluster_labels_b2_after,
  mode="index"
)
print(paste0("Batch 1 ARI: ", b1_ari))
print(paste0("Batch 2 ARI: ", b2_ari))
```